#!/usr/bin/env python3
#
# Create the gallery html page from the list of images found in img/
# using the database data.csv
#

from datetime import date
from pathlib import Path
from typing import Any, Dict, List, Optional, TextIO, Tuple
import argparse
import html
import os
import re

slug_re = re.compile(r"""
  ^
  \*\*\*\**     # 3 or more stars
  \s*           # whitespace
  ([a-z0-9-]+)  # slug (filename/URL); must contain only URL-safe characters
  \s*
  $
""", re.X)

field_re = re.compile(r"""
  ^
  ([a-z_]+)     # key
  \s*           # whitespace
  :
  \s*           # whitespace
  (.*)          # value
  \s*
  $
""", re.X)


def match_slug(line: str) -> Optional[str]:
    match = slug_re.match(line)
    if match:
        return match.group(1)
    else:
        return None


def split_notes(filename: str) -> List[Dict[str, Any]]:
    notes: List[Dict[str, Any]] = []
    note: Dict[str, Any] = {}
    def close_note() -> None:
        nonlocal note, notes
        if 'slug' in note:
            notes.append(note)
        note = { 'slug': '', 'lines': [], }
    with open(filename) as file:
        for line in file:
            slug = match_slug(line)
            if slug:
                close_note()
                note['slug'] = slug
            elif note:
                note['lines'].append(line)
            # else discard lines (at the beginning of the file)
    close_note()
    return notes


def parse_field(line: str) -> Optional[Tuple[str, str]]:
    match = field_re.match(line)
    if match:
        return (match.group(1), match.group(2))
    else:
        return None


# Format:
# - head section containing metadata section followed by document body.
# - metadata section is made of lines of the form "name: value",
#   blank lines are skipped until reaching a line that's not of the
#   "key: value".
# - the body is anything that follows the metadata section.
#
# Sample input:
#
#   title: Hello World
#   date: 2022-09-04
#   Something something
#   something
#
# If in the future we need more metadata or more structured metadata
# field values, we should switch to a standard data format like JSON or YAML
# for the head section.
#
def parse_note(note: Dict[str, Any]) -> Dict[str, Any]:
    slug: str = note['slug']
    stream = iter(note['lines'])
    title = None
    date_ = None
    body = []
    # Parse head section
    try:
        while True:
            line = next(stream)
            field = parse_field(line)
            if field:
                key, value = field
                if key == '':
                    pass
                elif key == 'title':
                    title = value
                elif key == 'date':
                    try:
                        date_ = date.fromisoformat(value)
                    except ValueError:
                        raise Exception(f"{slug}: malformed date: {value}")
                else:
                    raise Exception(f"{slug}: unsupported field: {key}")
            else:
                body.append(line)
                break
    except StopIteration:
        pass
    if not title:
        raise Exception(f"{slug}: missing title")
    if not date_:
        raise Exception(f"{slug}: missing date")
    # Parse body
    try:
        while True:
            body.append(next(stream))
    except StopIteration:
        pass

    return {
        'slug': slug,
        'title': title,
        'date': date_,
        'body': body,
    }


def parse_notes_from_file(filename: str) -> List[Dict[str, Any]]:
    notes = split_notes(filename)
    return [ parse_note(x) for x in notes ]


def write_note_page(note: Dict[str, Any]) -> None:
    folder = Path(note['slug'])
    md_file = folder / 'index.md'
    os.makedirs(folder, exist_ok=True)
    with open(md_file, 'w') as output:
        output.write(f"""
% {note['title']}
% {note['date']}

{"".join(note['body'])}
""")


#
# Create a main page that serves as a table of contents
# and one page per entry found in the input file.
#
def generate(input_notes_file: str,
             md_output: TextIO,
             makefile_output: TextIO) -> None:
    md_output.write(
        f"""% Notes
<!-- generated by './build' -->
"""
    )
    makefile_output.write('NOTE_PATHS =')
    notes = parse_notes_from_file(input_notes_file)
    for note in notes:
        # write to index
        md_output.write(f"""* [{note['title']}]({note['slug']})
""")
        # write to makefile
        makefile_output.write(f""" \\\n  notes/{note['slug']}""")

        # write individual page
        write_note_page(note)
    makefile_output.write("\n")

def main() -> None:
    with open('index.md', 'w') as md_output:
        with open('index.mk', 'w') as makefile_output:
            generate('notes.txt', md_output, makefile_output)

main()
